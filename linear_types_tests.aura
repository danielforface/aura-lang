// Test: Linear Type Enforcement - Move Semantics

// Test 1: Simple move - should work
fn test_simple_move() {
    let model = ai.load_model("model.onnx");
    let data = tensor.new(10);
    let result = ai.infer(model, data);
    io.println("inference complete");
}

// Test 2: Double-use after move - should FAIL
fn test_use_after_move() {
    let model = ai.load_model("model.onnx");
    let data1 = tensor.new(10);
    let data2 = tensor.new(5);
    
    let result1 = ai.infer(model, data1);  // model is moved here
    let result2 = ai.infer(model, data2);  // ERROR: use after move
}

// Test 3: Copy types should allow reuse
fn test_copy_reuse() {
    let x = 5;
    let y = x;  // OK: u32 is Copy
    let z = x;  // OK: u32 is Copy
    let w = x + y + z;  // OK
}

// Test 4: Tensor move
fn test_tensor_move() {
    let t = tensor.new(100);
    tensor.set(t, 0, 42);  // OK
    tensor.set(t, 1, 43);  // ERROR: t already consumed by previous call
}

// Test 5: Constructor move
fn test_constructor_move() {
    let model = ai.load_model("model.onnx");
    let wrapped = MyModel(model);  // model is moved into constructor
    let wrapped2 = MyModel(model);  // ERROR: use after move
}

// Test 6: Explicit use patterns
fn test_explicit_use() {
    let model = ai.load_model("model.onnx");
    
    // OK: explicitly passed and ownership transferred
    process(model);
    
    // ERROR: model was consumed by process()
    let _ = ai.infer(model, tensor.new(10));
}

fn process(m: Model) {
    // m ownership is consumed here
    io.println("processing");
}
