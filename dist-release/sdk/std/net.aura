# AuraSDK stdlib: std::net
# Network operations with formal race condition detection
# 
# This module provides thread-safe networking primitives guaranteed by:
# 1. Race Detector: Formal verification of concurrent network access patterns
# 2. Ownership System: Strict linear resource tracking for socket lifetime
# 3. Synchronization Proof: Automatic lock analysis for thread-safe operations
#
# Safety Properties Verified:
# - No data races on socket buffers (read/write operations)
# - No use-after-close errors on socket descriptors
# - Proper synchronization of concurrent operations
# - No deadlocks in lock-based synchronization

namespace std::net

# Socket represents a network endpoint with linear lifetime semantics
# The socket cannot be used after being closed (enforced at compile time)
type Socket = {
    fd: i32,              # file descriptor (owned linear resource)
    state: SocketState,   # current state (Open/Closed/Error)
    lock: Mutex<()>,      # synchronization for state changes
}

# Socket state tracking for race detector
enum SocketState = Open | Closed | Error(String)

# Establishes connection and returns owned socket
# Race detector verifies: single owner, no concurrent closes
fn connect(host: String, port: u16) -> Socket
  where Socket is linear, no_race_detector_violation

# Sends data with automatic race detection
# Verifies: synchronized access to socket buffer, no concurrent reads/writes
fn send(socket: &Socket, data: &[u8]) -> Result<i32, String>
  where data_race_free(socket), lock_held(socket.lock)

# Receives data with automatic race detection
fn recv(socket: &Socket, buffer: &mut [u8]) -> Result<i32, String>
  where data_race_free(socket), lock_held(socket.lock)

# Closes socket with verified cleanup
# Race detector verifies: all pending operations complete before close
fn close(socket: linear Socket) -> Result<(), String>
  where linear_resource_freed(socket)
